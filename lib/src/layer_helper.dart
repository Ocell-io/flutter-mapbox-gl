// This file is generated by
// ./scripts/lib/generate.dart

part of mapbox_gl;


class SymbolProperties{
    /// Label placement relative to its geometry.
    static const symbolPlacement = "symbol-placement";

    /// Distance between two symbol anchors.
    static const symbolSpacing = "symbol-spacing";

    /// If true, the symbols will not cross tile edges to avoid mutual
    /// collisions. Recommended in layers that don't have enough padding in
    /// the vector tile to prevent collisions, or if it is a point symbol
    /// layer placed after a line symbol layer. When using a client that
    /// supports global collision detection, like Mapbox GL JS version 0.42.0
    /// or greater, enabling this property is not needed to prevent clipped
    /// labels at tile boundaries.
    static const symbolAvoidEdges = "symbol-avoid-edges";

    /// Sorts features in ascending order based on this value. Features with
    /// lower sort keys are drawn and placed first.  When `icon-allow-overlap`
    /// or `text-allow-overlap` is `false`, features with a lower sort key
    /// will have priority during placement. When `icon-allow-overlap` or
    /// `text-allow-overlap` is set to `true`, features with a higher sort key
    /// will overlap over features with a lower sort key.
    static const symbolSortKey = "symbol-sort-key";

    /// Controls the order in which overlapping symbols in the same layer are
    /// rendered
    static const symbolZOrder = "symbol-z-order";

    /// If true, the icon will be visible even if it collides with other
    /// previously drawn symbols.
    static const iconAllowOverlap = "icon-allow-overlap";

    /// If true, other symbols can be visible even if they collide with the
    /// icon.
    static const iconIgnorePlacement = "icon-ignore-placement";

    /// If true, text will display without their corresponding icons when the
    /// icon collides with other symbols and the text does not.
    static const iconOptional = "icon-optional";

    /// In combination with `symbol-placement`, determines the rotation
    /// behavior of icons.
    static const iconRotationAlignment = "icon-rotation-alignment";

    /// Scales the original size of the icon by the provided factor. The new
    /// pixel size of the image will be the original pixel size multiplied by
    /// `icon-size`. 1 is the original size; 3 triples the size of the image.
    static const iconSize = "icon-size";

    /// Scales the icon to fit around the associated text.
    static const iconTextFit = "icon-text-fit";

    /// Size of the additional area added to dimensions determined by
    /// `icon-text-fit`, in clockwise order: top, right, bottom, left.
    static const iconTextFitPadding = "icon-text-fit-padding";

    /// Name of image in sprite to use for drawing an image background.
    static const iconImage = "icon-image";

    /// Rotates the icon clockwise.
    static const iconRotate = "icon-rotate";

    /// Size of the additional area around the icon bounding box used for
    /// detecting symbol collisions.
    static const iconPadding = "icon-padding";

    /// If true, the icon may be flipped to prevent it from being rendered
    /// upside-down.
    static const iconKeepUpright = "icon-keep-upright";

    /// Offset distance of icon from its anchor. Positive values indicate
    /// right and down, while negative values indicate left and up. Each
    /// component is multiplied by the value of `icon-size` to obtain the
    /// final offset in pixels. When combined with `icon-rotate` the offset
    /// will be as if the rotated direction was up.
    static const iconOffset = "icon-offset";

    /// Part of the icon placed closest to the anchor.
    static const iconAnchor = "icon-anchor";

    /// Orientation of icon when map is pitched.
    static const iconPitchAlignment = "icon-pitch-alignment";

    /// Orientation of text when map is pitched.
    static const textPitchAlignment = "text-pitch-alignment";

    /// In combination with `symbol-placement`, determines the rotation
    /// behavior of the individual glyphs forming the text.
    static const textRotationAlignment = "text-rotation-alignment";

    /// Value to use for a text label. If a plain `string` is provided, it
    /// will be treated as a `formatted` with default/inherited formatting
    /// options.
    static const textField = "text-field";

    /// Font stack to use for displaying text.
    static const textFont = "text-font";

    /// Font size.
    static const textSize = "text-size";

    /// The maximum line width for text wrapping.
    static const textMaxWidth = "text-max-width";

    /// Text leading value for multi-line text.
    static const textLineHeight = "text-line-height";

    /// Text tracking amount.
    static const textLetterSpacing = "text-letter-spacing";

    /// Text justification options.
    static const textJustify = "text-justify";

    /// Radial offset of text, in the direction of the symbol's anchor. Useful
    /// in combination with `text-variable-anchor`, which defaults to using
    /// the two-dimensional `text-offset` if present.
    static const textRadialOffset = "text-radial-offset";

    /// To increase the chance of placing high-priority labels on the map, you
    /// can provide an array of `text-anchor` locations: the renderer will
    /// attempt to place the label at each location, in order, before moving
    /// onto the next label. Use `text-justify: auto` to choose justification
    /// based on anchor position. To apply an offset, use the
    /// `text-radial-offset` or the two-dimensional `text-offset`.
    static const textVariableAnchor = "text-variable-anchor";

    /// Part of the text placed closest to the anchor.
    static const textAnchor = "text-anchor";

    /// Maximum angle change between adjacent characters.
    static const textMaxAngle = "text-max-angle";

    /// The property allows control over a symbol's orientation. Note that the
    /// property values act as a hint, so that a symbol whose language doesnâ€™t
    /// support the provided orientation will be laid out in its natural
    /// orientation. Example: English point symbol will be rendered
    /// horizontally even if array value contains single 'vertical' enum
    /// value. The order of elements in an array define priority order for the
    /// placement of an orientation variant.
    static const textWritingMode = "text-writing-mode";

    /// Rotates the text clockwise.
    static const textRotate = "text-rotate";

    /// Size of the additional area around the text bounding box used for
    /// detecting symbol collisions.
    static const textPadding = "text-padding";

    /// If true, the text may be flipped vertically to prevent it from being
    /// rendered upside-down.
    static const textKeepUpright = "text-keep-upright";

    /// Specifies how to capitalize text, similar to the CSS `text-transform`
    /// property.
    static const textTransform = "text-transform";

    /// Offset distance of text from its anchor. Positive values indicate
    /// right and down, while negative values indicate left and up. If used
    /// with text-variable-anchor, input values will be taken as absolute
    /// values. Offsets along the x- and y-axis will be applied automatically
    /// based on the anchor position.
    static const textOffset = "text-offset";

    /// If true, the text will be visible even if it collides with other
    /// previously drawn symbols.
    static const textAllowOverlap = "text-allow-overlap";

    /// If true, other symbols can be visible even if they collide with the
    /// text.
    static const textIgnorePlacement = "text-ignore-placement";

    /// If true, icons will display without their corresponding text when the
    /// text collides with other symbols and the icon does not.
    static const textOptional = "text-optional";

    /// Whether this layer is displayed.
    static const visibility = "visibility";

    /// The opacity at which the icon will be drawn.
    static const iconOpacity = "icon-opacity";

    /// The color of the icon. This can only be used with sdf icons.
    static const iconColor = "icon-color";

    /// The color of the icon's halo. Icon halos can only be used with SDF
    /// icons.
    static const iconHaloColor = "icon-halo-color";

    /// Distance of halo to the icon outline.
    static const iconHaloWidth = "icon-halo-width";

    /// Fade out the halo towards the outside.
    static const iconHaloBlur = "icon-halo-blur";

    /// Distance that the icon's anchor is moved from its original placement.
    /// Positive values indicate right and down, while negative values
    /// indicate left and up.
    static const iconTranslate = "icon-translate";

    /// Controls the frame of reference for `icon-translate`.
    static const iconTranslateAnchor = "icon-translate-anchor";

    /// The opacity at which the text will be drawn.
    static const textOpacity = "text-opacity";

    /// The color with which the text will be drawn.
    static const textColor = "text-color";

    /// The color of the text's halo, which helps it stand out from
    /// backgrounds.
    static const textHaloColor = "text-halo-color";

    /// Distance of halo to the font outline. Max text halo width is 1/4 of
    /// the font-size.
    static const textHaloWidth = "text-halo-width";

    /// The halo's fadeout distance towards the outside.
    static const textHaloBlur = "text-halo-blur";

    /// Distance that the text's anchor is moved from its original placement.
    /// Positive values indicate right and down, while negative values
    /// indicate left and up.
    static const textTranslate = "text-translate";

    /// Controls the frame of reference for `text-translate`.
    static const textTranslateAnchor = "text-translate-anchor";

}


class CircleProperties{
    /// Sorts features in ascending order based on this value. Features with a
    /// higher sort key will appear above features with a lower sort key.
    static const circleSortKey = "circle-sort-key";

    /// Whether this layer is displayed.
    static const visibility = "visibility";

    /// Circle radius.
    static const circleRadius = "circle-radius";

    /// The fill color of the circle.
    static const circleColor = "circle-color";

    /// Amount to blur the circle. 1 blurs the circle such that only the
    /// centerpoint is full opacity.
    static const circleBlur = "circle-blur";

    /// The opacity at which the circle will be drawn.
    static const circleOpacity = "circle-opacity";

    /// The geometry's offset. Values are [x, y] where negatives indicate left
    /// and up, respectively.
    static const circleTranslate = "circle-translate";

    /// Controls the frame of reference for `circle-translate`.
    static const circleTranslateAnchor = "circle-translate-anchor";

    /// Controls the scaling behavior of the circle when the map is pitched.
    static const circlePitchScale = "circle-pitch-scale";

    /// Orientation of circle when map is pitched.
    static const circlePitchAlignment = "circle-pitch-alignment";

    /// The width of the circle's stroke. Strokes are placed outside of the
    /// `circle-radius`.
    static const circleStrokeWidth = "circle-stroke-width";

    /// The stroke color of the circle.
    static const circleStrokeColor = "circle-stroke-color";

    /// The opacity of the circle's stroke.
    static const circleStrokeOpacity = "circle-stroke-opacity";

}


class LineProperties{
    /// The display of line endings.
    static const lineCap = "line-cap";

    /// The display of lines when joining.
    static const lineJoin = "line-join";

    /// Used to automatically convert miter joins to bevel joins for sharp
    /// angles.
    static const lineMiterLimit = "line-miter-limit";

    /// Used to automatically convert round joins to miter joins for shallow
    /// angles.
    static const lineRoundLimit = "line-round-limit";

    /// Sorts features in ascending order based on this value. Features with a
    /// higher sort key will appear above features with a lower sort key.
    static const lineSortKey = "line-sort-key";

    /// Whether this layer is displayed.
    static const visibility = "visibility";

    /// The opacity at which the line will be drawn.
    static const lineOpacity = "line-opacity";

    /// The color with which the line will be drawn.
    static const lineColor = "line-color";

    /// The geometry's offset. Values are [x, y] where negatives indicate left
    /// and up, respectively.
    static const lineTranslate = "line-translate";

    /// Controls the frame of reference for `line-translate`.
    static const lineTranslateAnchor = "line-translate-anchor";

    /// Stroke thickness.
    static const lineWidth = "line-width";

    /// Draws a line casing outside of a line's actual path. Value indicates
    /// the width of the inner gap.
    static const lineGapWidth = "line-gap-width";

    /// The line's offset. For linear features, a positive value offsets the
    /// line to the right, relative to the direction of the line, and a
    /// negative value to the left. For polygon features, a positive value
    /// results in an inset, and a negative value results in an outset.
    static const lineOffset = "line-offset";

    /// Blur applied to the line, in pixels.
    static const lineBlur = "line-blur";

    /// Specifies the lengths of the alternating dashes and gaps that form the
    /// dash pattern. The lengths are later scaled by the line width. To
    /// convert a dash length to pixels, multiply the length by the current
    /// line width. Note that GeoJSON sources with `lineMetrics: true`
    /// specified won't render dashed lines to the expected scale. Also note
    /// that zoom-dependent expressions will be evaluated only at integer zoom
    /// levels.
    static const lineDasharray = "line-dasharray";

    /// Name of image in sprite to use for drawing image lines. For seamless
    /// patterns, image width must be a factor of two (2, 4, 8, ..., 512).
    /// Note that zoom-dependent expressions will be evaluated only at integer
    /// zoom levels.
    static const linePattern = "line-pattern";

    /// Defines a gradient with which to color a line feature. Can only be
    /// used with GeoJSON sources that specify `"lineMetrics": true`.
    static const lineGradient = "line-gradient";

}


class FillProperties{
    /// Sorts features in ascending order based on this value. Features with a
    /// higher sort key will appear above features with a lower sort key.
    static const fillSortKey = "fill-sort-key";

    /// Whether this layer is displayed.
    static const visibility = "visibility";

    /// Whether or not the fill should be antialiased.
    static const fillAntialias = "fill-antialias";

    /// The opacity of the entire fill layer. In contrast to the `fill-color`,
    /// this value will also affect the 1px stroke around the fill, if the
    /// stroke is used.
    static const fillOpacity = "fill-opacity";

    /// The color of the filled part of this layer. This color can be
    /// specified as `rgba` with an alpha component and the color's opacity
    /// will not affect the opacity of the 1px stroke, if it is used.
    static const fillColor = "fill-color";

    /// The outline color of the fill. Matches the value of `fill-color` if
    /// unspecified.
    static const fillOutlineColor = "fill-outline-color";

    /// The geometry's offset. Values are [x, y] where negatives indicate left
    /// and up, respectively.
    static const fillTranslate = "fill-translate";

    /// Controls the frame of reference for `fill-translate`.
    static const fillTranslateAnchor = "fill-translate-anchor";

    /// Name of image in sprite to use for drawing image fills. For seamless
    /// patterns, image width and height must be a factor of two (2, 4, 8,
    /// ..., 512). Note that zoom-dependent expressions will be evaluated only
    /// at integer zoom levels.
    static const fillPattern = "fill-pattern";

}


class Expressions{
    static const let = "let";
    static const varExpression = "var";
    static const literal = "literal";
    static const array = "array";
    static const at = "at";
    static const inExpression = "in";
    static const caseExpression = "case";
    static const match = "match";
    static const coalesce = "coalesce";
    static const step = "step";
    static const interpolate = "interpolate";
    static const interpolateHcl = "interpolate-hcl";
    static const interpolateLab = "interpolate-lab";
    static const ln2 = "ln2";
    static const pi = "pi";
    static const e = "e";
    static const typeof = "typeof";
    static const string = "string";
    static const number = "number";
    static const boolean = "boolean";
    static const object = "object";
    static const collator = "collator";
    static const format = "format";
    static const image = "image";
    static const numberFormat = "number-format";
    static const toStringExpression = "to-string";
    static const toNumber = "to-number";
    static const toBoolean = "to-boolean";
    static const toRgba = "to-rgba";
    static const toColor = "to-color";
    static const rgb = "rgb";
    static const rgba = "rgba";
    static const get = "get";
    static const has = "has";
    static const length = "length";
    static const properties = "properties";
    static const featureState = "feature-state";
    static const geometryType = "geometry-type";
    static const id = "id";
    static const zoom = "zoom";
    static const heatmapDensity = "heatmap-density";
    static const lineProgress = "line-progress";
    static const accumulated = "accumulated";
    static const plus = "+";
    static const multiply = "*";
    static const minus = "-";
    static const divide = "/";
    static const precent = "%";
    static const xor = "^";
    static const sqrt = "sqrt";
    static const log10 = "log10";
    static const ln = "ln";
    static const log2 = "log2";
    static const sin = "sin";
    static const cos = "cos";
    static const tan = "tan";
    static const asin = "asin";
    static const acos = "acos";
    static const atan = "atan";
    static const min = "min";
    static const max = "max";
    static const round = "round";
    static const abs = "abs";
    static const ceil = "ceil";
    static const floor = "floor";
    static const equal = "==";
    static const notEqual = "!=";
    static const larger = ">";
    static const smaller = "<";
    static const largerOrEqual = ">=";
    static const smallerOrEqual = "<=";
    static const all = "all";
    static const any = "any";
    static const not = "!";
    static const isSupportedScript = "is-supported-script";
    static const upcase = "upcase";
    static const downcase = "downcase";
    static const concat = "concat";
    static const resolvedLocale = "resolved-locale";
}
